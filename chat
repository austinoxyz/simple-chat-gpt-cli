#!/usr/bin/python3

import os
import sys
import subprocess
import time
import math
import json
import re
from typing import List

from pathlib import Path  # for xdg

import openai


APP_NAME = 'simple-chat'

DEFAULT_MODEL = 'gpt-3.5-turbo'

# ansi color sequences
RED = '\033[31m'
GREEN = '\033[32m'
YELLOW = '\033[33m'
BLUE = '\033[34m'

# store terminal width for text justification
TERM_WIDTH = 80


# write ansi colored terminal output
def write_colored_output(output, color, end='\n') -> None:
    sys.stdout.write(color + output + '\033[0m' + end)

def hex_to_truecolor_ansi(color) -> str:
    r = int(color[1:3], base=16)
    g = int(color[3:5], base=16)
    b = int(color[5:7], base=16)
    return f"\x1b[38;2;{r};{g};{b}m"

def truecolor_ify(string_to_print, color) -> str:
    return hex_to_truecolor_ansi(color) + string_to_print + '\x1b[0m'

truecolor_pattern = re.compile(r'\x1b\[([\d;]*)([A-Za-z])')
def len_truecolor(string: str) -> int:
    return len(truecolor_pattern.sub('', string))

# write truecolor ansi colored terminal output
def write_truecolor_output(output, color, end='\n') -> None:
    sys.stdout.write(hex_to_truecolor_ansi(color) + output + '\x1b[0m' + end)

def center_truecolor(string: str, width=TERM_WIDTH):
    length = len_truecolor(string)
    if length >= width:
        return string
    padding = ' ' * math.floor((width - len_truecolor(string)) / 2)
    return padding + string + padding

def rjust_truecolor(string: str, width=TERM_WIDTH):
    length = len_truecolor(string)
    if length >= width:
        return string
    return (' ' * math.floor((width - len_truecolor(string)))) + string

def split_string_into_len_n_substrings(input_string: str, n: int) -> List[str]:
    return [input_string[i:i+n] for i in range(0, len(input_string), n)]

def wrap_text(text: str, width_box: (int, int), pos: (int)) -> List[str]:
    wrapped_text = []
    words = text.split(' ')
    if len(words) == 1:
        return words
    line = words[0]
    begin = pos
    start_x, end_x = width_box
    max_width = end_x - start_x
    for word in words[1:]:
        if len(line) + len(word) < max_width:
            line += ' ' + word
        else:
            if len(wrapped_text) == 0:
                begin = start_x
            wrapped_text.append(line)
            line = word
    wrapped_text.append(line)
    wrapped_text = [line for line in wrapped_text if line != '']
    return wrapped_text

def wrap_truecolor_text(text: str, width_box: (int, int), pos: (int)) -> List[str]:
    wrapped_text = []
    words = text.split(' ')
    if len(words) == 1:
        return words
    line = words[0]
    begin = pos
    start_x, end_x = width_box
    max_width = end_x - start_x
    for word in words[1:]:
        if len_truecolor(line) + len_truecolor(word) < max_width:
            line += ' ' + word
        else:
            if len(wrapped_text) == 0:
                begin = start_x
            wrapped_text.append(line)
            line = word
    wrapped_text.append(line)
    wrapped_text = [line for line in wrapped_text if line != '']
    return wrapped_text






# use xclip to put the last chat completion in the clipboard
def set_clipboard_text(text) -> None:
    p = subprocess.Popen(['xclip', '-selection', 'clipboard'], stdin=subprocess.PIPE)
    p.stdin.write(text.encode('utf-8'))
    p.stdin.close()
    p.wait()






## XDG stuff
def get_config_dir() -> str:
    config_dir = os.getenv('XDG_CONFIG_HOME', '')
    if config_dir == '' or config_dir[0] != '/':
        return str(Path.home().joinpath('.config', APP_NAME))
    return str(Path(config_dir).joinpath(APP_NAME))

def get_data_dir() -> str:
    data_dir = os.getenv('XDG_DATA_HOME', '')
    if data_dir == '' or data_dir[0] != '/':
        return str(Path.home().joinpath('.local/share', APP_NAME))
    return str(Path(data_dir).joinpath(APP_NAME))








def load_prompt_names(prompts_dir) -> List[str]:
    return [filename[:-7] for filename in os.listdir(prompts_dir) if filename.endswith('.prompt')]

def load_prompt(prompt_name, prompts_dir) -> str:
    prompt_file_name = prompt_name + '.prompt'
    prompt_path = os.path.join(prompts_dir, prompt_file_name)
    try:
        with open(prompt_path, 'r') as prompt_file:
            prompt = prompt_file.read()
    except IOError:
        print(f"Couldn't read {prompt_path}. Check your prompts_dir!")
        sys.exit(1)
    print(f'Loaded prompt at {prompt_path}')
    return prompt

def save_prompt(prompt, prompt_name, prompts_dir) -> None:
    prompt_file_name = prompt_name + '.prompt'
    prompt_path = os.path.join(prompts_dir, prompt_file_name)
    print(f'Saving to {prompt_path}')
    try:
        with open(prompt_path, 'w') as prompt_file:
            prompt_file.write(prompt)
    except IOError:
        print(f"Couldn't write to {prompt_path}.")



def load_config(config_file_name):
    try:
        json_raw = ''
        with open(config_file_name, 'r') as config_file:
            json_raw += config_file.read()
        config = json.loads(json_raw)
    except IOError:
        print(f"Couldn't read {config_file_name}. Wheres your config?")
        sys.exit(1)
    except JSONDecodeError:
        print(f"Malformed json in {config_file_name}:")
        import traceback
        print(traceback.format_exc())
    return config

def load_api_key(api_key_file_name) -> str:
    try:
        with open(api_key_file_name, 'r') as api_key_file:
            key = api_key_file.readline()
    except IOError:
        print(f"Couldn't read {api_key_file_name}. Check your config!")
        sys.exit(1)
    return key

def load_token_usage(token_usage_file_name):
    try:
        with open(token_usage_file_name, 'r') as token_usage_file:
            token_usage = json.loads(token_usage_file.readline())
    except IOError:
        print(f"Couldn't read {token_usage_file_name}. Check your config!")
        sys.exit(1)
    return token_usage

def account_token_usage(request_token_usage) -> None:
    pass






config_file_name = 'config.json'
config = load_config(get_config_dir() + '/config.json')

openai.api_key_path = config["api_key_file"]

model = DEFAULT_MODEL
if "model" in config:
    model = config["model"]

token_usage = load_token_usage(get_data_dir() + '/token_usage.json')
session_token_usage = { "completion_tokens": 0, "prompt_tokens": 0, "total_tokens": 0 }

prompt = "After being given a google search query, you will provide raw markdown that resembles the first 5 results. If provided a number, give the url of that search result."
prompt_names = load_prompt_names(get_data_dir() + '/prompts/')

def list_saved_prompts() -> None:
    for i, name in enumerate(prompt_names):
        print(f"\t{i+1}. {name}")




commands = {'exit': 'exit simple-chat-gpt-cli', 
            'help': 'display the message you are currently reading.',
            'clip': 'store the contents of the last chat completion in the clipboard.', 
            'prompt new': 'create a new prompt and begin using it.', 
            'prompt list': f"list the saved prompts located in your {truecolor_ify('prompts_dir', config['colors']['green'])}", 
            'prompt load': f"load a saved prompt from your {truecolor_ify('prompts_dir', config['colors']['green'])}" }




def print_startup_message() -> None:
    print(flush=True)
    print('Welcome to simple-chat-gpt-cli'.center(TERM_WIDTH))
    print(center_truecolor(f"\ttype {truecolor_ify('exit', config['colors']['blue'])} to exit, or \
{truecolor_ify('help', config['colors']['blue'])} for a list of commands"))
    print(flush=True)

def print_command_usage(command_name: str, usage_info: int) -> None:
    colored_command = truecolor_ify(command_name, config['colors']['blue'])
    half_term_width = int(TERM_WIDTH / 2)
    usage_split = wrap_truecolor_text(usage_info, (half_term_width + 1, TERM_WIDTH - int(TERM_WIDTH * 0.1)), half_term_width + 1)
    print(rjust_truecolor(colored_command, width=(half_term_width - 1)), end='')
    print(f"  {usage_split[0]}")
    if len(usage_split) == 0:
        return
    for s in usage_split[1:]:
        print(f"{' ' * (half_term_width + 1)}{s}")

def print_help_message() -> None:
    command_name_total_space = int(TERM_WIDTH * 0.35)
    for command_name in commands:
        colored_command = truecolor_ify(command_name, config['colors']['blue'])
        usage_split = wrap_truecolor_text(commands[command_name], 
                                (command_name_total_space + 2, TERM_WIDTH), 
                                command_name_total_space + 2)
        print(rjust_truecolor(colored_command, width=(command_name_total_space)), end='')
        print(f"  {usage_split[0]}")
        if len(usage_split) == 0:
            return
        for s in usage_split[1:]:
            print(f"{' ' * (command_name_total_space + 2)}{s}")
    print(flush=True)

def print_prompt() -> None:
    print(f"{truecolor_ify('   >>> ', config['colors']['yellow'])}", end='')





# main
print_startup_message()
last_response = ''
while True:
    messages = []
    while True:
        print_prompt(); message = input()

        # TODO implement `help`, 
        # TODO implement `save`, 
        # TODO implement `prompt new`, `prompt load`, `prompt list`
        # TODO implement `personality new`, `personality load` 
        # TODO implement `clip code [n]`
        if message == 'exit':
            account_token_usage(session_token_usage)
            print(flush=True)
            sys.exit(0)
        elif message == 'help':
            print_help_message()
            continue
        elif message == 'clip':
            if last_response == '':
                print(center_truecolor(f"Must provide an initial message before you can \
{truecolor_ify('clip', config['colors']['blue'])}", TERM_WIDTH))
                continue
            set_clipboard_text(last_response)
            continue
        elif message == 'prompt new':
            if last_response != '':
                print('Are you sure you want to leave the current personality? y/n'.center(TERM_WIDTH))
                print_prompt(); are_you_sure = input()
                if are_you_sure not in ['y', 'yes']:
                    continue
                messages = []
            print('Enter your prompt:'.center(TERM_WIDTH)); print(flush=True)
            print_prompt(); prompt = input()
            print('Would you like to save this prompt for future use?'.center(TERM_WIDTH))
            print_prompt(); are_you_sure = input()
            if are_you_sure in ['y', 'yes']:
                while True:
                    print('What would you like to name this prompt?'.center(TERM_WIDTH))
                    print_prompt(); prompt_name = input()
                    if prompt_name in prompt_names:
                        print('There is already a prompt with that name. Do you want to overwrite it?'.center(TERM_WIDTH))
                        print_prompt(); are_you_sure = input()
                        if are_you_sure not in ['y', 'yes']:
                            print('Not saving prompt.'.center(TERM_WIDTH))
                            break
                    save_prompt(prompt, prompt_name, get_data_dir() + '/prompts/')
                    break
            messages.append({"role": "system", "content": prompt})
            continue
        elif message == 'prompt list':
            print(flush=True)
            print("Saved prompts:".center(TERM_WIDTH))
            print(flush=True)
            list_saved_prompts()
            print(flush=True)
            continue
        elif message == 'prompt load':
            if last_response != '':
                print('Are you sure you want to leave the current personality? y/n'.center(TERM_WIDTH))
                print_prompt(); are_you_sure = input()
                if are_you_sure not in ['y', 'yes']:
                    continue
                messages = []
            print(flush=True)
            print("Select from saved prompts (enter desired number): ".center(TERM_WIDTH))
            print(flush=True)
            list_saved_prompts()
            print(flush=True)
            while True:
                print_prompt(); selected_prompt_n = input()
                if not selected_prompt_n.isdigit():
                    print("Must enter number of desired prompt.".center(TERM_WIDTH))
                    continue
                selected_prompt_name = prompt_names[int(selected_prompt_n) - 1]
                prompt = load_prompt(selected_prompt_name, get_data_dir() + '/prompts/')
                messages.append({"role": "system", "content": prompt})
                break
            continue

        messages.append({"role": "user", "content": message})

        collected_chunks = []
        collected_messages = []
        chunk_tokens = 0

        start_time = time.time()
        response = openai.ChatCompletion.create(
            model=DEFAULT_MODEL,
            messages=messages,
            temperature=0,
            stream=True)

        start_cursor = int(TERM_WIDTH * 0.2)
        end_cursor = TERM_WIDTH - int(TERM_WIDTH * 0.25)

        print(f"{' ' * start_cursor}")
        for chunk in response:

            chunk_time = time.time() - start_time  
            collected_chunks.append(chunk)  
            chunk_delta = json.loads(f"{chunk['choices'][0]['delta']}")

            chunk_tokens = 0
            cursor = start_cursor
            if "role" in chunk_delta:
                continue
            elif "content" in chunk_delta:
                chunk_message = chunk_delta["content"]
                collected_messages.append(chunk_message)  

                # TODO padding on either side of chat completion response not working
                if ' ' in chunk_message and cursor > end_cursor:
                    print(chunk_message, flush=True)
                    if cursor != start_cursor:
                        print("\n", flush=True)
                    print(f"{' ' * start_cursor}", flush=True)
                    cursor = start_cursor
                cursor += len(chunk_message)

                chunk_tokens += 1
                print(chunk_message, end='', flush=True)
            last_response = ''.join(collected_messages)

        messages.append({"role": "assistant", "content": message})
        session_token_usage["completion_tokens"] += chunk_tokens
        print('\n\n', end='')

